import {convertToBuffer, fromHex, isEmptyData, numToUint8, toHex, uint32ArrayFrom} from "./chunk-5F2IFVYA.js";
import {__awaiter, __generator, __values} from "./chunk-LGOS2CJL.js";
import {__async, __asyncGenerator, __await, __forAwait, __spreadProps, __spreadValues} from "./chunk-G42SKTPL.js";

// node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
var resolveEventStreamSerdeConfig = (input) => __spreadProps(__spreadValues({}, input), {
    eventStreamMarshaller: input.eventStreamSerdeProvider(input)
});

// node_modules/@aws-crypto/crc32/build/module/aws_crc32.js
var AwsCrc32 = (
    /** @class */
    function () {
        function AwsCrc322() {
            this.crc32 = new Crc32();
        }

        AwsCrc322.prototype.update = function (toHash) {
            if (isEmptyData(toHash)) return;
            this.crc32.update(convertToBuffer(toHash));
        };
        AwsCrc322.prototype.digest = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2, numToUint8(this.crc32.digest())];
                });
            });
        };
        AwsCrc322.prototype.reset = function () {
            this.crc32 = new Crc32();
        };
        return AwsCrc322;
    }()
);

// node_modules/@aws-crypto/crc32/build/module/index.js
var Crc32 = (
    /** @class */
    function () {
        function Crc322() {
            this.checksum = 4294967295;
        }

        Crc322.prototype.update = function (data) {
            var e_1, _a;
            try {
                for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                    var byte = data_1_1.value;
                    this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally {
                try {
                    if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            return this;
        };
        Crc322.prototype.digest = function () {
            return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc322;
    }()
);
var a_lookUpTable = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
var lookupTable = uint32ArrayFrom(a_lookUpTable);

// node_modules/@smithy/eventstream-codec/dist-es/Int64.js
var Int64 = class _Int64 {
    constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
    }

    static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
            bytes[i] = remaining;
        }
        if (number < 0) {
            negate(bytes);
        }
        return new _Int64(bytes);
    }

    valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
            negate(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
    }

    toString() {
        return String(this.valueOf());
    }
};

function negate(bytes) {
    for (let i = 0; i < 8; i++) {
        bytes[i] ^= 255;
    }
    for (let i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0) break;
    }
}

// node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var HeaderMarshaller = class {
    constructor(toUtf8, fromUtf8) {
        this.toUtf8 = toUtf8;
        this.fromUtf8 = fromUtf8;
    }

    format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
            const bytes = this.fromUtf8(headerName);
            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
            out.set(chunk, position);
            position += chunk.byteLength;
        }
        return out;
    }

    formatHeaderValue(header) {
        switch (header.type) {
            case "boolean":
                return Uint8Array.from([header.value ? 0 : 1]);
            case "byte":
                return Uint8Array.from([2, header.value]);
            case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
            case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
            case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
            case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
            case "string":
                const utf8Bytes = this.fromUtf8(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
            case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
            case "uuid":
                if (!UUID_PATTERN.test(header.value)) {
                    throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
        }
    }

    parse(headers) {
        const out = {};
        let position = 0;
        while (position < headers.byteLength) {
            const nameLength = headers.getUint8(position++);
            const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
            position += nameLength;
            switch (headers.getUint8(position++)) {
                case 0:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: true
                    };
                    break;
                case 1:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: false
                    };
                    break;
                case 2:
                    out[name] = {
                        type: BYTE_TAG,
                        value: headers.getInt8(position++)
                    };
                    break;
                case 3:
                    out[name] = {
                        type: SHORT_TAG,
                        value: headers.getInt16(position, false)
                    };
                    position += 2;
                    break;
                case 4:
                    out[name] = {
                        type: INT_TAG,
                        value: headers.getInt32(position, false)
                    };
                    position += 4;
                    break;
                case 5:
                    out[name] = {
                        type: LONG_TAG,
                        value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
                    };
                    position += 8;
                    break;
                case 6:
                    const binaryLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: BINARY_TAG,
                        value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
                    };
                    position += binaryLength;
                    break;
                case 7:
                    const stringLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: STRING_TAG,
                        value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
                    };
                    position += stringLength;
                    break;
                case 8:
                    out[name] = {
                        type: TIMESTAMP_TAG,
                        value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
                    };
                    position += 8;
                    break;
                case 9:
                    const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
                    position += 16;
                    out[name] = {
                        type: UUID_TAG,
                        value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`
                    };
                    break;
                default:
                    throw new Error(`Unrecognized header type tag`);
            }
        }
        return out;
    }
};
var HEADER_VALUE_TYPE;
(function (HEADER_VALUE_TYPE2) {
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
var BOOLEAN_TAG = "boolean";
var BYTE_TAG = "byte";
var SHORT_TAG = "short";
var INT_TAG = "integer";
var LONG_TAG = "long";
var BINARY_TAG = "binary";
var STRING_TAG = "string";
var TIMESTAMP_TAG = "timestamp";
var UUID_TAG = "uuid";
var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

// node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
var PRELUDE_MEMBER_LENGTH = 4;
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
var CHECKSUM_LENGTH = 4;
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;

function splitMessage({
                          byteLength,
                          byteOffset,
                          buffer
                      }) {
    if (byteLength < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
    }
    const view = new DataView(buffer, byteOffset, byteLength);
    const messageLength = view.getUint32(0, false);
    if (byteLength !== messageLength) {
        throw new Error("Reported message length does not match received message length");
    }
    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
    const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
    if (expectedPreludeChecksum !== checksummer.digest()) {
        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
    }
    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
    if (expectedMessageChecksum !== checksummer.digest()) {
        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
    }
    return {
        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
    };
}

// node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
var EventStreamCodec = class {
    constructor(toUtf8, fromUtf8) {
        this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);
        this.messageBuffer = [];
        this.isEndOfStream = false;
    }

    feed(message) {
        this.messageBuffer.push(this.decode(message));
    }

    endOfStream() {
        this.isEndOfStream = true;
    }

    getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessage() {
                return message;
            },
            isEndOfStream() {
                return isEndOfStream;
            }
        };
    }

    getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessages() {
                return messages;
            },
            isEndOfStream() {
                return isEndOfStream;
            }
        };
    }

    encode({
               headers: rawHeaders,
               body
           }) {
        const headers = this.headerMarshaller.format(rawHeaders);
        const length = headers.byteLength + body.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers, 12);
        out.set(body, headers.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
    }

    decode(message) {
        const {
            headers,
            body
        } = splitMessage(message);
        return {
            headers: this.headerMarshaller.parse(headers),
            body
        };
    }

    formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
    }
};

// node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
var MessageDecoderStream = class {
    constructor(options) {
        this.options = options;
    }

    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }

    asyncIterator() {
        return __asyncGenerator(this, null, function* () {
            try {
                for (var iter = __forAwait(this.options.inputStream), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                    const bytes = temp.value;
                    const decoded = this.options.decoder.decode(bytes);
                    yield decoded;
                }
            } catch (temp) {
                error = [temp];
            } finally {
                try {
                    more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                } finally {
                    if (error)
                        throw error[0];
                }
            }
        });
    }
};

// node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
var MessageEncoderStream = class {
    constructor(options) {
        this.options = options;
    }

    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }

    asyncIterator() {
        return __asyncGenerator(this, null, function* () {
            try {
                for (var iter = __forAwait(this.options.messageStream), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                    const msg = temp.value;
                    const encoded = this.options.encoder.encode(msg);
                    yield encoded;
                }
            } catch (temp) {
                error = [temp];
            } finally {
                try {
                    more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                } finally {
                    if (error)
                        throw error[0];
                }
            }
            if (this.options.includeEndFrame) {
                yield new Uint8Array(0);
            }
        });
    }
};

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
var SmithyMessageDecoderStream = class {
    constructor(options) {
        this.options = options;
    }

    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }

    asyncIterator() {
        return __asyncGenerator(this, null, function* () {
            try {
                for (var iter = __forAwait(this.options.messageStream), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                    const message = temp.value;
                    const deserialized = yield new __await(this.options.deserializer(message));
                    if (deserialized === void 0) continue;
                    yield deserialized;
                }
            } catch (temp) {
                error = [temp];
            } finally {
                try {
                    more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                } finally {
                    if (error)
                        throw error[0];
                }
            }
        });
    }
};

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
var SmithyMessageEncoderStream = class {
    constructor(options) {
        this.options = options;
    }

    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }

    asyncIterator() {
        return __asyncGenerator(this, null, function* () {
            try {
                for (var iter = __forAwait(this.options.inputStream), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                    const chunk = temp.value;
                    const payloadBuf = this.options.serializer(chunk);
                    yield payloadBuf;
                }
            } catch (temp) {
                error = [temp];
            } finally {
                try {
                    more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                } finally {
                    if (error)
                        throw error[0];
                }
            }
        });
    }
};

// node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js
function getChunkedStream(source) {
    let currentMessageTotalLength = 0;
    let currentMessagePendingLength = 0;
    let currentMessage = null;
    let messageLengthBuffer = null;
    const allocateMessage = (size) => {
        if (typeof size !== "number") {
            throw new Error("Attempted to allocate an event message where size was not a number: " + size);
        }
        currentMessageTotalLength = size;
        currentMessagePendingLength = 4;
        currentMessage = new Uint8Array(size);
        const currentMessageView = new DataView(currentMessage.buffer);
        currentMessageView.setUint32(0, size, false);
    };
    const iterator = function () {
        return __asyncGenerator(this, null, function* () {
            const sourceIterator = source[Symbol.asyncIterator]();
            while (true) {
                const {
                    value,
                    done
                } = yield new __await(sourceIterator.next());
                if (done) {
                    if (!currentMessageTotalLength) {
                        return;
                    } else if (currentMessageTotalLength === currentMessagePendingLength) {
                        yield currentMessage;
                    } else {
                        throw new Error("Truncated event message received.");
                    }
                    return;
                }
                const chunkLength = value.length;
                let currentOffset = 0;
                while (currentOffset < chunkLength) {
                    if (!currentMessage) {
                        const bytesRemaining = chunkLength - currentOffset;
                        if (!messageLengthBuffer) {
                            messageLengthBuffer = new Uint8Array(4);
                        }
                        const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
                        messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
                        currentMessagePendingLength += numBytesForTotal;
                        currentOffset += numBytesForTotal;
                        if (currentMessagePendingLength < 4) {
                            break;
                        }
                        allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
                        messageLengthBuffer = null;
                    }
                    const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
                    currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
                    currentMessagePendingLength += numBytesToWrite;
                    currentOffset += numBytesToWrite;
                    if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
                        yield currentMessage;
                        currentMessage = null;
                        currentMessageTotalLength = 0;
                        currentMessagePendingLength = 0;
                    }
                }
            }
        });
    };
    return {
        [Symbol.asyncIterator]: iterator
    };
}

// node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
function getMessageUnmarshaller(deserializer, toUtf8) {
    return function (message) {
        return __async(this, null, function* () {
            const {
                value: messageType
            } = message.headers[":message-type"];
            if (messageType === "error") {
                const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
                unmodeledError.name = message.headers[":error-code"].value;
                throw unmodeledError;
            } else if (messageType === "exception") {
                const code = message.headers[":exception-type"].value;
                const exception = {
                    [code]: message
                };
                const deserializedException = yield deserializer(exception);
                if (deserializedException.$unknown) {
                    const error = new Error(toUtf8(message.body));
                    error.name = code;
                    throw error;
                }
                throw deserializedException[code];
            } else if (messageType === "event") {
                const event = {
                    [message.headers[":event-type"].value]: message
                };
                const deserialized = yield deserializer(event);
                if (deserialized.$unknown) return;
                return deserialized;
            } else {
                throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
            }
        });
    };
}

// node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller = class {
    constructor({
                    utf8Encoder,
                    utf8Decoder
                }) {
        this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
        this.utfEncoder = utf8Encoder;
    }

    deserialize(body, deserializer) {
        const inputStream = getChunkedStream(body);
        return new SmithyMessageDecoderStream({
            messageStream: new MessageDecoderStream({
                inputStream,
                decoder: this.eventStreamCodec
            }),
            deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder)
        });
    }

    serialize(inputStream, serializer) {
        return new MessageEncoderStream({
            messageStream: new SmithyMessageEncoderStream({
                inputStream,
                serializer
            }),
            encoder: this.eventStreamCodec,
            includeEndFrame: true
        });
    }
};

// node_modules/@smithy/eventstream-serde-browser/dist-es/utils.js
var readableStreamtoIterable = (readableStream) => ({
    [Symbol.asyncIterator]: function () {
        return __asyncGenerator(this, null, function* () {
            const reader = readableStream.getReader();
            try {
                while (true) {
                    const {
                        done,
                        value
                    } = yield new __await(reader.read());
                    if (done) return;
                    yield value;
                }
            } finally {
                reader.releaseLock();
            }
        });
    }
});
var iterableToReadableStream = (asyncIterable) => {
    const iterator = asyncIterable[Symbol.asyncIterator]();
    return new ReadableStream({
        pull(controller) {
            return __async(this, null, function* () {
                const {
                    done,
                    value
                } = yield iterator.next();
                if (done) {
                    return controller.close();
                }
                controller.enqueue(value);
            });
        }
    });
};

// node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller2 = class {
    constructor({
                    utf8Encoder,
                    utf8Decoder
                }) {
        this.universalMarshaller = new EventStreamMarshaller({
            utf8Decoder,
            utf8Encoder
        });
    }

    deserialize(body, deserializer) {
        const bodyIterable = isReadableStream(body) ? readableStreamtoIterable(body) : body;
        return this.universalMarshaller.deserialize(bodyIterable, deserializer);
    }

    serialize(input, serializer) {
        const serialziedIterable = this.universalMarshaller.serialize(input, serializer);
        return typeof ReadableStream === "function" ? iterableToReadableStream(serialziedIterable) : serialziedIterable;
    }
};
var isReadableStream = (body) => typeof ReadableStream === "function" && body instanceof ReadableStream;

// node_modules/@smithy/eventstream-serde-browser/dist-es/provider.js
var eventStreamSerdeProvider = (options) => new EventStreamMarshaller2(options);

export {
    AwsCrc32,
    resolveEventStreamSerdeConfig,
    eventStreamSerdeProvider
};
//# sourceMappingURL=chunk-XT3UHRHO.js.map
